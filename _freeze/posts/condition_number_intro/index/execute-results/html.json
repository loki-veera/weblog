{
  "hash": "fd34dbdc9f4e2c6b61d9490e653c8628",
  "result": {
    "markdown": "---\ntitle: Condition Number Introduction\nauthor: Lokesh Veeramacheneni\ndate: 'July 10, 2023'\ncategories:\n  - linear algebra\n  - condition number\nformat:\n  html:\n    code-fold: false\nexecute:\n  enables: true\n---\n\n### Keywords:\ncondition number, matrix multiplications, linear algebra.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport torch\n```\n:::\n\n\nIn this post, we will look into what is a condition number and how to calculate it. Along with that, we will see an example of how the condition number affects the system of linear equations.\n\n## What is condition number?\n\nCondition number $(\\kappa)$ specifies the sensitivity of the matrix multiplication to small changes in the input. A matrix with a smaller condition number is said to be well-conditioned and vice versa. The condition number of a matrix $M$ is computed by the ratio of largest to smallest singular value of the matrix $M$.\n\n$$\n    \\kappa(M) = \\frac{\\sigma_{max}(M)}{\\sigma_{min}(M)}\n$$\n\nThe conditional number of unitary matrices is 1. These matrices are important for the orthogonalization of the neural networks. <br>\nUnitary matrices: A matrix whose inverse equals it's complex transpose.\n$$\n    U^* = U^{-1}\n$$\n$$\n    UU^* = I\n$$\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef get_condition_number(matrix):\n    _, sigma, _ = torch.linalg.svd(matrix)\n    return max(sigma)/min(sigma)\n```\n:::\n\n\n## Ill conditioned system\n\nThe example of an ill-conditioned matrix given in [1] is\n\n\\begin{pmatrix}\n1 & 1 \\\\\n1 & 1.0001\n\\end{pmatrix}\n\nNow let's see why this matrix is ill conditioned. <br>\nLet us consider a set of linear equations represented in the matrix form $Ax = b$ with A being the above matrix.\n\nLet's consider $b$ matrix as \n\\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}\nThe system of equations is represented as \n$$\n\\left(\\matrix{1 & 1 \\cr 1 & 1.0001}\\right)\\left(\\matrix{x \\cr y}\\right) = \n\\left(\\matrix{1 \\cr 1}\\right)\n$$\nThe solution to the system is \n$\\left(\\matrix{x \\cr y}\\right) = \\left(\\matrix{1 \\cr 0}\\right)$\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nM = torch.Tensor([[1, 1], [1, 1.0001]])\nb = torch.Tensor([[1], [1]])\nresult = torch.linalg.inv(M)@b\nprint(f\"The solution to the system with above conditions is: \\n {result}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe solution to the system with above conditions is: \n tensor([[1.],\n        [0.]])\n```\n:::\n:::\n\n\nLet's say because of numerical error $b$ matrix is slightly changed as\n\\begin{pmatrix}\n1 \\\\\n1.0002\n\\end{pmatrix}\n\nNow the system of equations are:\n$$\n\\left(\\matrix{1 & 1 \\cr 1 & 1.0001}\\right)\\left(\\matrix{x \\cr y}\\right) = \n\\left(\\matrix{1 \\cr 1.0002}\\right)\n$$\nThe solution to the system is \n$\\left(\\matrix{x \\cr y}\\right) = \\left(\\matrix{-1 \\cr 2}\\right)$\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx = torch.Tensor([[1], [1.0002]])\nresult = torch.linalg.inv(M)@x\nprint(f\"The solution to the system with slight change in b is: \\n {result}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe solution to the system with slight change in b is: \n tensor([[-1.],\n        [ 2.]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ncondition_number = get_condition_number(M)\nprint(f\"Condition number of the matrix M is {condition_number}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCondition number of the matrix M is 39949.36328125\n```\n:::\n:::\n\n\nAs one can see that with the change in one of the element ($4^{th}$ decimal), changed the solution in units place. So that is why this matrix is ill conditioned with large condition number of 39949.363.\n\n## Well conditioned system\nLet's look at how well conditioned matrix behaves to small changes.<br>\nAn example of such a matrix is \n\\begin{pmatrix}\n3 & 2 \\\\\n1 & 4\n\\end{pmatrix} with the condition number 2.62.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nM_well = torch.Tensor([[3, 2], [1, 4]])\nprint(get_condition_number(M_well))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntensor(2.6180)\n```\n:::\n:::\n\n\nWith $b$ matrix as \n\\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}\nThe solution to the system is\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nresult =  torch.linalg.inv(M_well)@b\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntensor([[0.2000],\n        [0.2000]])\n```\n:::\n:::\n\n\nWith $b$ matrix slightly changed as \n\\begin{pmatrix}\n1 \\\\\n1.0002\n\\end{pmatrix}\nThe solution to the system is\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nresult = torch.linalg.inv(M_well)@x\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntensor([[0.2000],\n        [0.2001]])\n```\n:::\n:::\n\n\nOne can see that, with the change in $4^{th}$ decimal, the solution to the system is only changed in $3^{rd}$ decimal.\n\nIn the next post, we will see why this is important in training neural networks and how condition number affects the training regime.\n\n## References:\n1. Strang, Gilbert. Linear algebra and its applications. Belmont, CA: Thomson, Brooks/Cole, 2006.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}